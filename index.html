<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Housing Data Central</title>

  <!-- Chart.js via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 24px; line-height: 1.35; }
    h1 { margin: 0 0 6px; }
    .sub { color: #555; margin: 0 0 18px; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 16px; margin: 14px 0; }
    canvas { max-width: 100%; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border-bottom: 1px solid #eee; padding: 10px 8px; text-align: right; }
    th:first-child, td:first-child { text-align: left; }
    th { background: #fafafa; position: sticky; top: 0; }
    .note { color: #666; font-size: 13px; margin-top: 8px; }
    .error { color: #b00020; white-space: pre-wrap; }
    .ok { color: #1a7f37; }
  </style>
</head>

<body>
  <div style="display:flex; gap:12px; align-items:baseline; flex-wrap:wrap;">
  <h1 style="margin:0;">HousingDataCentral</h1>

  <label for="seriesSelect" style="color:#555;">
    Series:
    <select id="seriesSelect" style="margin-left:6px; padding:6px 8px;"></select>
  </label>
</div>

<p class="sub" id="seriesMeta">
  Loading series...
</p>

  <div class="card">
    <div id="status">Loading data...</div>
    <div id="err" class="error"></div>
  </div>

  <div class="card">
    <h2 style="margin-top:0;">Last 20 years (line chart)</h2>
    <canvas id="chart" height="110"></canvas>
    <div class="note">Chart shows the last 20 years ending at the latest available observation.</div>
  </div>

  <div class="card">
    <h2 style="margin-top:0;">Most recent 18 months (table)</h2>
    <div style="overflow:auto; max-height: 520px;">
      <table>
        <thead>
          <tr>
            <th>Month reported</th>
            <th>Raw data number</th>
            <th>% change y/y</th>
            <th>% change q/q</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
    <div class="note">
      q/q definition: average of last 3 months vs average of prior 3 months (percent change).
    </div>
  </div>

<script>
  // =========================================================
  // CONFIG
  // =========================================================
  const FRED_OBS_URL = "https://fred-proxy.patrick-grow.workers.dev";

  const SERIES_LIST = [
    { id: "HSN1F",        name: "New Home Sales (SAAR)" },
    { id: "MSACSR",       name: "Months of Inventory (New Homes)" },
    { id: "MSPNHSUS",     name: "Median Sales Price (New Homes)" },
    { id: "MSPUS",        name: "Median Sales Price (All Homes)" },
    { id: "HOUST",        name: "Housing Starts (Total)" },
    { id: "HOUST1F",      name: "Housing Starts (Single-Family)" },
    { id: "PERMIT1",      name: "Permits (Single-Family)" },
    { id: "MORTGAGE30US", name: "30-Year Mortgage Rate (monthly avg)" }
  ];

  const RECESSION_SERIES_ID = "USREC"; // NBER recession indicator (0/1, monthly)

  // =========================================================
  // Helpers
  // =========================================================
  const fmtNumber0 = new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 });
  const fmtPct1 = new Intl.NumberFormat("en-US", { maximumFractionDigits: 1, minimumFractionDigits: 1 });
  const fmtMonth = new Intl.DateTimeFormat("en-US", { year: "numeric", month: "short" });

  // Per-series formatting (keeps table “obviously correct”)
  function formatValue(seriesId, v) {
    if (v === null || v === undefined) return "-";
    if (seriesId === "MORTGAGE30US") return fmtPct1.format(v) + "%";
    if (seriesId === "MSPNHSUS" || seriesId === "MSPUS") return "$" + fmtNumber0.format(v);
    return fmtNumber0.format(v);
  }

  function formatPct(v) {
    if (v === null || v === undefined) return "-";
    return fmtPct1.format(v) + "%";
  }

  function parseFredValue(v) {
    if (v === "." || v === null || v === undefined) return null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }

  function mean(nums) {
    const clean = nums.filter(n => n !== null && n !== undefined);
    if (clean.length === 0) return null;
    return clean.reduce((a, b) => a + b, 0) / clean.length;
  }

  function pctChange(curr, prev) {
    if (curr === null || prev === null) return null;
    if (prev === 0) return null;
    return (curr / prev - 1) * 100;
  }

  function addYears(dateObj, years) {
    const d = new Date(dateObj);
    d.setFullYear(d.getFullYear() + years);
    return d;
  }

  function monthKey(d) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    return y + "-" + m; // e.g., 2024-07
  }

  // Convert any frequency (weekly included) into monthly observations by averaging within each month.
  function toMonthly(obs) {
    const buckets = new Map(); // key -> { date: firstOfMonth, values: [] }

    for (const o of obs) {
      const key = monthKey(o.date);
      if (!buckets.has(key)) {
        buckets.set(key, {
          date: new Date(o.date.getFullYear(), o.date.getMonth(), 1),
          values: []
        });
      }
      buckets.get(key).values.push(o.value);
    }

    const monthly = [];
    for (const [, b] of buckets) {
      const avg = mean(b.values);
      if (avg !== null) monthly.push({ date: b.date, value: avg });
    }

    monthly.sort((a, b) => a.date - b.date);
    return monthly;
  }

  function sliceLast20Years(obs) {
    const latest = obs[obs.length - 1].date;
    const start = addYears(latest, -20);
    return obs.filter(o => o.date >= start);
  }

  // =========================================================
  // Fetch (via your Cloudflare Worker)
  // =========================================================
  async function fetchSeriesMonthly(seriesId) {
    const url = new URL(FRED_OBS_URL);
    url.searchParams.set("series_id", seriesId);
    url.searchParams.set("file_type", "json");

    const resp = await fetch(url.toString());
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error("Request failed (" + resp.status + ")\n" + txt);
    }

    const data = await resp.json();
    if (!data || !Array.isArray(data.observations)) {
      throw new Error("Unexpected response shape for " + seriesId);
    }

    const obs = data.observations
      .map(o => ({ date: new Date(o.date + "T00:00:00"), value: parseFredValue(o.value) }))
      .filter(o => o.value !== null)
      .sort((a, b) => a.date - b.date);

    if (obs.length === 0) throw new Error("No observations returned for " + seriesId);

    return toMonthly(obs);
  }

  // =========================================================
  // Table calcs (monthly)
  // =========================================================
  function computeTableRows(obsMonthly) {
    const rows = obsMonthly.map((o, i) => {
      const yoy = (i >= 12) ? pctChange(o.value, obsMonthly[i - 12].value) : null;

      // QoQ definition: avg(last 3 months) vs avg(prior 3 months)
      const currQ = (i >= 2) ? mean([obsMonthly[i].value, obsMonthly[i - 1].value, obsMonthly[i - 2].value]) : null;
      const prevQ = (i >= 5) ? mean([obsMonthly[i - 3].value, obsMonthly[i - 4].value, obsMonthly[i - 5].value]) : null;
      const qoq = (currQ !== null && prevQ !== null) ? pctChange(currQ, prevQ) : null;

      return { date: o.date, value: o.value, yoy, qoq };
    });

    return rows.slice(-18).reverse(); // newest first
  }

  function renderTable(seriesId, rows18) {
    const tbody = document.getElementById("tbody");
    tbody.innerHTML = "";

    for (const r of rows18) {
      const tr = document.createElement("tr");

      const monthTd = document.createElement("td");
      monthTd.textContent = fmtMonth.format(r.date);

      const valTd = document.createElement("td");
      valTd.textContent = formatValue(seriesId, r.value);

      const yoyTd = document.createElement("td");
      yoyTd.textContent = formatPct(r.yoy);

      const qoqTd = document.createElement("td");
      qoqTd.textContent = formatPct(r.qoq);

      tr.appendChild(monthTd);
      tr.appendChild(valTd);
      tr.appendChild(yoyTd);
      tr.appendChild(qoqTd);

      tbody.appendChild(tr);
    }
  }

  // =========================================================
  // Recession shading (USREC)
  // =========================================================
  let chart; // Chart.js instance

  const recessionShadingPlugin = {
    id: "recessionShading",
    beforeDatasetsDraw(chartInstance, args, opts) {
      const { ctx, chartArea, scales } = chartInstance;
      if (!chartArea) return;

      const xScale = scales.x;
      const bands = (opts && opts.bands) ? opts.bands : [];
      if (!bands.length) return;

      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.08)";

      for (const b of bands) {
        const x0 = xScale.getPixelForValue(b.startLabel);
        const x1 = xScale.getPixelForValue(b.endLabel);
        const left = Math.min(x0, x1);
        const width = Math.abs(x1 - x0);
        ctx.fillRect(left, chartArea.top, width, chartArea.bottom - chartArea.top);
      }
      ctx.restore();
    }
  };

  function buildRecessionBands(usrec20y, labels20y) {
    const recByLabel = new Map(usrec20y.map(o => [fmtMonth.format(o.date), o.value]));
    const bands = [];

    let inRec = false;
    let startLabel = null;

    for (let i = 0; i < labels20y.length; i++) {
      const lab = labels20y[i];
      const v = recByLabel.get(lab);
      const isRec = (v === 1);

      if (isRec && !inRec) {
        inRec = true;
        startLabel = lab;
      }

      if (!isRec && inRec) {
        inRec = false;
        const endLabel = labels20y[i - 1] || startLabel;
        bands.push({ startLabel, endLabel });
        startLabel = null;
      }
    }

    if (inRec && startLabel) {
      bands.push({ startLabel, endLabel: labels20y[labels20y.length - 1] });
    }

    return bands;
  }

  function renderChart(seriesName, obs20y, usrec20y) {
    const labels = obs20y.map(o => fmtMonth.format(o.date));
    const values = obs20y.map(o => o.value);

    const bands = buildRecessionBands(usrec20y, labels);

    const ctx = document.getElementById("chart");
    if (chart) chart.destroy();

    chart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [{
          label: seriesName,
          data: values,
          tension: 0.15,
          pointRadius: 0,
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: true },
          recessionShading: { bands }
        },
        scales: {
          x: { ticks: { maxTicksLimit: 12 } },
          y: { ticks: { callback: (v) => fmtNumber0.format(v) } }
        }
      },
      plugins: [recessionShadingPlugin]
    });
  }

  // =========================================================
  // UI + Main
  // =========================================================
  function populateDropdown() {
    const sel = document.getElementById("seriesSelect");
    sel.innerHTML = "";
    for (const s of SERIES_LIST) {
      const opt = document.createElement("option");
      opt.value = s.id;
      opt.textContent = s.name;
      sel.appendChild(opt);
    }
  }

  async function loadAndRender(seriesId) {
    const status = document.getElementById("status");
    const err = document.getElementById("err");
    const meta = document.getElementById("seriesMeta");

    const selected = SERIES_LIST.find(s => s.id === seriesId) || { id: seriesId, name: seriesId };

    try {
      status.textContent = "Fetching " + selected.id + "...";
      err.textContent = "";
      meta.textContent = "Selected: " + selected.name;

      const [obsMonthly, usrecMonthly] = await Promise.all([
        fetchSeriesMonthly(seriesId),
        fetchSeriesMonthly(RECESSION_SERIES_ID)
      ]);

      const latest = obsMonthly[obsMonthly.length - 1].date;
      status.innerHTML = "<span class='ok'>Loaded</span> " + obsMonthly.length + " monthly observations. Latest: " + fmtMonth.format(latest) + ".";

      const obs20y = sliceLast20Years(obsMonthly);
      const usrec20y = sliceLast20Years(usrecMonthly);

      renderChart(selected.name, obs20y, usrec20y);
      renderTable(seriesId, computeTableRows(obsMonthly));

    } catch (e) {
      status.textContent = "Could not load data.";
      err.textContent = String(e && e.message ? e.message : e);
      console.error(e);
    }
  }

  (function init() {
    populateDropdown();

    const sel = document.getElementById("seriesSelect");
    sel.addEventListener("change", () => loadAndRender(sel.value));

    // initial load = first item
    loadAndRender(sel.value || SERIES_LIST[0].id);
  })();
</script>

</body>
</html>
