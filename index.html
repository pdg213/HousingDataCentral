<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" /> 
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Housing Data Central</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --border:#e6e6e6;
      --muted:#666;
      --bg:#ffffff;
      --card:#ffffff;
      --shadow: 0 1px 10px rgba(0,0,0,0.04);
      --good:#1a7f37;
      --bad:#b00020;
      --warn:#9a6a00;
      --pill:#fafafa;
    }
    * { box-sizing: border-box; }
    body { font-family: Arial, sans-serif; margin: 22px; line-height: 1.35; background: var(--bg); color:#111; }
    h1 { margin: 0 0 6px; font-size: 22px; }
    .sub { color: var(--muted); margin: 0 0 12px; }

    .topbar{
      display:flex; gap:12px; flex-wrap: wrap; align-items:center;
      margin: 10px 0 12px;
    }
    .topbar .group{ display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    label { font-size: 12.5px; color: var(--muted); }
    select, input[type="number"], button{
      padding: 7px 9px; border:1px solid var(--border); border-radius:10px; background:#fff;
      font-size: 13px;
    }
    button{ cursor:pointer; }
    button:disabled{ opacity:0.55; cursor:not-allowed; }

    .status { border: 1px solid var(--border); border-radius: 12px; padding: 14px 14px; margin: 10px 0 14px; background: var(--card); box-shadow: var(--shadow); }
    .ok { color: var(--good); }
    .warn { color: var(--warn); }
    .error { color: var(--bad); white-space: pre-wrap; margin-top: 8px; }

    .pill { display:inline-block; padding:3px 8px; border:1px solid var(--border); border-radius: 999px; font-size: 12px; color:#333; background: var(--pill); }
    .small { font-size: 12.5px; color: var(--muted); }

    .kpiGrid{
      display:grid; gap:12px;
      grid-template-columns: 1fr;
      margin: 12px 0 14px;
    }
    @media (min-width: 900px) {
      .kpiGrid{ grid-template-columns: repeat(3, 1fr); }
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    @media (min-width: 1100px) {
      .grid { grid-template-columns: 1fr 1fr; }
    }

    .card { border: 1px solid var(--border); border-radius: 12px; padding: 14px; background: var(--card); box-shadow: var(--shadow); }
    .card h2 { margin: 0 0 6px; font-size: 16px; }
    .meta { color: var(--muted); font-size: 12.5px; margin: 0 0 10px; }
    .note { color: var(--muted); font-size: 12.5px; margin-top: 8px; }
    canvas { width: 100% !important; height: 280px !important; }

    .kpiCard h3{ margin:0 0 6px; font-size: 13px; color:#111; }
    .kpiMain{ display:flex; justify-content: space-between; align-items: baseline; gap:10px; }
    .kpiValue{ font-size: 20px; font-weight: 700; }
    .kpiDelta{ font-size: 12.5px; color: var(--muted); }
    .kpiFooter{ display:flex; justify-content: space-between; align-items:center; gap:8px; margin-top: 8px; }
    .kpiTag{ font-size: 12px; padding:3px 8px; border:1px solid var(--border); border-radius:999px; background: var(--pill); color:#333; }
    .kpiTag.good{ border-color: rgba(26,127,55,0.35); }
    .kpiTag.warn{ border-color: rgba(154,106,0,0.35); }
    .kpiTag.bad{ border-color: rgba(176,0,32,0.25); }

    .tileErr{ margin-top: 8px; color: var(--bad); white-space: pre-wrap; font-size: 12.5px; }
    .tileStatus{ display:flex; justify-content: space-between; align-items:center; gap:10px; margin: 6px 0 10px; flex-wrap: wrap; }
    .tileStatus .left{ display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
  </style>
</head>

<body>
  <h1>Housing Dashboard</h1>
  <p class="sub">Single-file dashboard pulling public series from FRED via your Cloudflare proxy. Includes KPI monitoring, global controls, staleness detection, per-tile error isolation, and recession shading.</p>

  <div class="topbar">
    <div class="group">
      <label for="rangeSelect">Window</label>
      <select id="rangeSelect">
        <option value="5">5Y</option>
        <option value="10">10Y</option>
        <option value="20" selected>20Y</option>
        <option value="30">30Y</option>
        <option value="MAX">MAX</option>
      </select>

      <label for="smoothSelect">Smoothing</label>
      <select id="smoothSelect">
        <option value="0" selected>None</option>
        <option value="3">3M MA</option>
        <option value="6">6M MA</option>
      </select>

      <label for="dpRange">Down payment (Tile 1)</label>
      <input id="dpRange" type="range" min="0" max="50" step="1" value="20" style="width:220px;" />
      <span id="dpLabel" class="pill">20%</span>
    </div>

    <div class="group">
      <button id="refreshBtn">Refresh (clear local cache)</button>
      <button id="reloadBtn">Reload data</button>
    </div>
  </div>

  <div class="status">
    <div id="statusText">Loading…</div>
    <div id="errText" class="error"></div>
  </div>

  <!-- KPI STRIP -->
  <div id="kpiGrid" class="kpiGrid"></div>

  <!-- TILES CONTAINER -->
  <div id="tiles" class="grid"></div>

  <!-- AI COMMENTARY (MOVED TO BOTTOM) -->
  <div class="card" id="commentaryCard" style="margin-top:14px;">
    <h2 style="margin-top:0;">Commentary & Signals</h2>
    <div id="insightsStatus" class="small">Loading commentary...</div>

    <div style="margin:10px 0 0;">
      <div class="pill" style="margin-right:6px;">Auto signals</div>
      <span class="small">Derived from the latest deltas and thresholds.</span>
      <ul id="signalsBullets" style="margin: 8px 0 0 18px;"></ul>
    </div>

    <h3 style="margin:12px 0 6px; font-size:14px;">Builders (3 bullets each)</h3>
    <div id="buildersWrap"></div>

    <h3 style="margin:12px 0 6px; font-size:14px;">New home market (latest data)</h3>
    <ul id="marketBullets" style="margin: 8px 0 0 18px;"></ul>

    <div id="insightsErr" class="error"></div>
  </div>

<script>
/* =========================================================
   CONFIG
========================================================= */
const PROXY_BASE = "https://fred-proxy.patrick-grow.workers.dev";
const INSIGHTS_URL = PROXY_BASE.replace(/\/$/, "") + "/insights";

const SERIES = {
  PRICE_ZILLOW: "USAUCSFRCONDOSMSAMID",
  MORTGAGE_30Y: "MORTGAGE30US",

  EHS_SAAR: "EXHOSLUSM495S",
  EHS_MONTHS: "HOSSUPUSM673N",

  NEW_INV: "HNFSEPUSSA",
  NEW_MONTHS: "MSACSR",

  STARTS_SF: "HOUST1F",

  RES_WORKERS: "CES2023610001",

  SENTIMENT: "UMCSENT",
  UNRATE: "UNRATE",

  USREC: "USREC"
};

const CACHE_TTL_MS = 12 * 60 * 60 * 1000; // 12 hours
const CACHE_PREFIX = "fredcache_v2:";

const THRESH = {
  STALE_MONTHLY_DAYS: 62,
  AFFORD_YOY_GOOD: 0,
  STARTS_YOY_STRONG: 10,
  UNRATE_6M_RISE_WARN: 0.3
};

/* =========================================================
   DOM
========================================================= */
const elStatusText = document.getElementById("statusText");
const elErrText = document.getElementById("errText");
const elKpiGrid = document.getElementById("kpiGrid");
const elTiles = document.getElementById("tiles");

const elRange = document.getElementById("rangeSelect");
const elSmooth = document.getElementById("smoothSelect");
const elDp = document.getElementById("dpRange");
const elDpLabel = document.getElementById("dpLabel");
const elRefresh = document.getElementById("refreshBtn");
const elReload = document.getElementById("reloadBtn");

// Commentary DOM (now exists in body)
const elInsightsStatus = document.getElementById("insightsStatus");
const elInsightsErr = document.getElementById("insightsErr");
const elBuildersWrap = document.getElementById("buildersWrap");
const elMarketBullets = document.getElementById("marketBullets");
const elSignalsBullets = document.getElementById("signalsBullets");

/* =========================================================
   FORMATTERS
========================================================= */
const fmtMonth = new Intl.DateTimeFormat("en-US", { year: "numeric", month: "short" });
const fmtMoney0 = new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 });
const fmtNum0 = new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 });
const fmt1 = new Intl.NumberFormat("en-US", { maximumFractionDigits: 1, minimumFractionDigits: 1 });

function formatYM(ym){
  const [y,m] = ym.split("-");
  return fmtMonth.format(new Date(Number(y), Number(m)-1, 1));
}

/* =========================================================
   HELPERS
========================================================= */
function parseFredValue(v) {
  if (v === "." || v === null || v === undefined) return null;
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}
function ymdToDate(s) { return new Date(s + "T00:00:00"); }
function monthKey(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  return `${y}-${m}`;
}
function addYears(dateObj, years) {
  const d = new Date(dateObj);
  d.setFullYear(d.getFullYear() + years);
  return d;
}
function pctChange(curr, prev) {
  if (curr === null || prev === null || prev === 0) return null;
  return (curr / prev - 1) * 100;
}
function rollingMA(values, window){
  if (!window || window <= 1) return values.slice();
  const out = [];
  for (let i=0;i<values.length;i++){
    const slice = values.slice(Math.max(0, i-window+1), i+1).filter(v => v !== null && v !== undefined);
    out.push(slice.length ? (slice.reduce((a,b)=>a+b,0)/slice.length) : null);
  }
  return out;
}
function lastValue(arr){
  for (let i=arr.length-1;i>=0;i--){
    if (arr[i] !== null && arr[i] !== undefined) return arr[i];
  }
  return null;
}
function lastIndexOfNonNull(arr){
  for (let i=arr.length-1;i>=0;i--){
    if (arr[i] !== null && arr[i] !== undefined) return i;
  }
  return -1;
}
function daysBetween(a, b){
  const ms = Math.abs(b.getTime() - a.getTime());
  return ms / (1000*60*60*24);
}
function computeYoYFromAligned(values, lag=12){
  return values.map((v, i) => (i >= lag) ? pctChange(v, values[i-lag]) : null);
}
function changeOverN(values, n){
  return values.map((v, i) => (i >= n && v !== null && values[i-n] !== null) ? (v - values[i-n]) : null);
}
function monthlyPayment(loanAmount, annualRatePct, nMonths=360) {
  if (loanAmount === null || annualRatePct === null) return null;
  const r = (annualRatePct / 100) / 12;
  if (r === 0) return loanAmount / nMonths;
  const denom = 1 - Math.pow(1 + r, -nMonths);
  if (denom === 0) return null;
  return loanAmount * r / denom;
}

/* =========================================================
   FETCH + CACHE (localStorage)
========================================================= */
function cacheKeyForSeries(seriesId) { return CACHE_PREFIX + seriesId; }

function readCache(seriesId) {
  try {
    const raw = localStorage.getItem(cacheKeyForSeries(seriesId));
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return null;
    const { savedAt, data } = parsed;
    if (!savedAt || !data) return null;
    if ((Date.now() - savedAt) > CACHE_TTL_MS) return null;
    return data;
  } catch { return null; }
}
function writeCache(seriesId, data) {
  try {
    localStorage.setItem(cacheKeyForSeries(seriesId), JSON.stringify({ savedAt: Date.now(), data }));
  } catch { /* ignore */ }
}
function clearAllLocalCache(){
  try{
    const keys = [];
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (k && k.startsWith(CACHE_PREFIX)) keys.push(k);
    }
    keys.forEach(k => localStorage.removeItem(k));
  } catch { /* ignore */ }
}

async function fetchSeries(seriesId, { bypassCache=false } = {}) {
  if (!bypassCache){
    const cached = readCache(seriesId);
    if (cached && Array.isArray(cached.observations)) {
      const obsCached = cached.observations
        .map(o => ({ date: ymdToDate(o.date), value: parseFredValue(o.value) }))
        .filter(o => o.value !== null)
        .sort((a, b) => a.date - b.date);
      if (obsCached.length) return obsCached;
    }
  }

  const url = new URL(PROXY_BASE);
  url.searchParams.set("series_id", seriesId);
  url.searchParams.set("file_type", "json");
  if (bypassCache) url.searchParams.set("nocache", "1");

  const resp = await fetch(url.toString());
  if (!resp.ok) {
    const txt = await resp.text();
    throw new Error(`${seriesId} failed (${resp.status}). Response:\n${txt}`);
  }
  const data = await resp.json();
  writeCache(seriesId, data);

  if (!data || !Array.isArray(data.observations)) throw new Error(`${seriesId} unexpected response shape.`);
  const obs = data.observations
    .map(o => ({ date: ymdToDate(o.date), value: parseFredValue(o.value) }))
    .filter(o => o.value !== null)
    .sort((a, b) => a.date - b.date);

  if (!obs.length) throw new Error(`${seriesId}: no observations after filtering.`);
  return obs;
}

function toMonthlyAverage(obs) {
  const bucket = new Map();
  for (const o of obs) {
    const k = monthKey(o.date);
    const cur = bucket.get(k) || { sum: 0, count: 0, date: new Date(o.date.getFullYear(), o.date.getMonth(), 1) };
    cur.sum += o.value;
    cur.count += 1;
    bucket.set(k, cur);
  }
  return Array.from(bucket.values())
    .map(v => ({ date: v.date, value: v.sum / v.count }))
    .sort((a,b)=>a.date-b.date);
}

function sliceWindow(obs, windowYears){
  if (!obs.length) return obs;
  if (windowYears === "MAX") return obs.slice();
  const years = Number(windowYears);
  if (!Number.isFinite(years) || years <= 0) return obs.slice();
  const latest = obs[obs.length - 1].date;
  const start = addYears(latest, -years);
  return obs.filter(o => o.date >= start);
}

function alignMonthlyUnion(seriesList) {
  const maps = seriesList.map(s => {
    const m = new Map();
    s.obs.forEach(o => m.set(monthKey(o.date), o.value));
    return m;
  });

  const keySet = new Set();
  maps.forEach(m => m.forEach((_,k)=>keySet.add(k)));
  const keys = Array.from(keySet).sort();

  const valuesBySeries = maps.map(m => keys.map(k => m.has(k) ? m.get(k) : null));
  return { keys, valuesBySeries };
}

/* =========================================================
   RECESSION SHADING (USREC)
========================================================= */
function recessionRangesFromUSREC(usrecMonthlyObs) {
  const sorted = [...usrecMonthlyObs].sort((a,b)=>a.date-b.date);
  const ranges = [];
  let inRec = false;
  let start = null;

  for (const o of sorted) {
    const isRec = o.value >= 1;
    if (!inRec && isRec) { inRec = true; start = monthKey(o.date); }
    if (inRec && !isRec) {
      const end = monthKey(o.date);
      ranges.push({ startYM: start, endYM: end });
      inRec = false; start = null;
    }
  }
  if (inRec && start) {
    const last = monthKey(sorted[sorted.length - 1].date);
    const [y,m] = last.split("-");
    const end = new Date(Number(y), Number(m)-1, 1);
    end.setMonth(end.getMonth()+1);
    ranges.push({ startYM: start, endYM: monthKey(end) });
  }
  return ranges;
}

function makeRecessionPlugin(getRanges) {
  return {
    id: "recessionShading",
    beforeDatasetsDraw(chart) {
      const ranges = getRanges();
      if (!ranges || !ranges.length) return;

      const { ctx, chartArea, scales } = chart;
      const x = scales.x;
      if (!x || !chartArea) return;

      const labels = chart.data.labels || []; // YYYY-MM
      const labelToIndex = new Map(labels.map((lab,i)=>[lab,i]));

      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.06)";

      function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

      for (const r of ranges) {
        if (!labelToIndex.has(r.startYM)) continue;
        const i0 = labelToIndex.get(r.startYM);
        const i1 = labelToIndex.has(r.endYM) ? labelToIndex.get(r.endYM) : (labels.length - 1);

        const px0 = x.getPixelForValue(i0);
        const px1 = x.getPixelForValue(i1);

        const left = clamp(Math.min(px0, px1), chartArea.left, chartArea.right);
        const right = clamp(Math.max(px0, px1), chartArea.left, chartArea.right);

        ctx.fillRect(left, chartArea.top, right - left, chartArea.bottom - chartArea.top);
      }

      ctx.restore();
    }
  };
}

function makeLatestLabelPlugin() {
  return {
    id: "latestLabel",
    afterDatasetsDraw(chart) {
      const { ctx } = chart;
      const ds = chart.data.datasets || [];
      if (!ds.length) return;

      const lineIndex = ds.findIndex(d => d.type === "line");
      const idx = lineIndex >= 0 ? lineIndex : 0;
      const data = ds[idx].data || [];
      const lastIdx = lastIndexOfNonNull(data);
      if (lastIdx < 0) return;

      const xScale = chart.scales.x;
      const yScale = chart.scales[ds[idx].yAxisID || "y"];
      if (!xScale || !yScale) return;

      const x = xScale.getPixelForValue(lastIdx);
      const y = yScale.getPixelForValue(data[lastIdx]);

      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.72)";
      ctx.font = "12px Arial";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText("Latest", x + 6, y);
      ctx.restore();
    }
  };
}

/* =========================================================
   CHART BUILDER
========================================================= */
function makeMixedBarLineChart(canvas, labelsYM, barData, lineData, opts) {
  return new Chart(canvas, {
    type: "bar",
    data: {
      labels: labelsYM, // YYYY-MM
      datasets: [
        {
          type: "bar",
          label: opts.barLabel,
          data: barData,
          yAxisID: "yBar",
          backgroundColor: "rgba(60, 120, 200, 0.45)",
          borderColor: "rgba(60, 120, 200, 0.85)",
          borderWidth: 1
        },
        {
          type: "line",
          label: opts.lineLabel,
          data: lineData,
          yAxisID: "yLine",
          tension: 0.15,
          pointRadius: 0,
          borderWidth: 2,
          borderColor: "rgba(220, 90, 80, 0.95)"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: "index", intersect: false },
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            title: (items) => {
              const ym = items?.[0]?.label;
              return ym ? formatYM(ym) : "";
            }
          }
        },
        decimation: { enabled: true, algorithm: "lttb", samples: 500 }
      },
      scales: {
        x: {
          ticks: {
            maxTicksLimit: 12,
            callback: (val, idx) => formatYM(labelsYM[idx])
          }
        },
        yBar: {
          position: "left",
          ticks: { callback: (v) => opts.barTick(v) },
          title: { display: true, text: opts.barAxisTitle }
        },
        yLine: {
          position: "right",
          grid: { drawOnChartArea: false },
          ticks: { callback: (v) => opts.lineTick(v) },
          title: { display: true, text: opts.lineAxisTitle }
        }
      }
    }
  });
}

/* =========================================================
   TILE DEFINITIONS
========================================================= */
function lastUpdatedYM(labelsYM, values){
  const i = lastIndexOfNonNull(values);
  return i >= 0 ? labelsYM[i] : null;
}
function computeStaleness(updatedYM){
  if (!updatedYM) return { level:"warn", text:"Staleness: —" };
  const [y,m] = updatedYM.split("-");
  const updatedDate = new Date(Number(y), Number(m)-1, 1);
  const now = new Date();
  const d = daysBetween(updatedDate, now);

  if (d <= THRESH.STALE_MONTHLY_DAYS) return { level:"good", text:`Fresh (${Math.round(d)}d)` };
  if (d <= THRESH.STALE_MONTHLY_DAYS * 1.7) return { level:"warn", text:`Stale (${Math.round(d)}d)` };
  return { level:"bad", text:`Very stale (${Math.round(d)}d)` };
}
function setTileUpdateBadges(tileKey, updatedYM, staleness){
  const upd = document.getElementById(`upd_${tileKey}`);
  const stale = document.getElementById(`stale_${tileKey}`);
  if (upd) upd.textContent = updatedYM ? `Updated: ${formatYM(updatedYM)}` : "Updated: —";
  if (stale) {
    stale.textContent = staleness ? staleness.text : "Staleness: —";
    stale.style.borderColor = staleness.level === "good" ? "rgba(26,127,55,0.35)"
                         : staleness.level === "bad"  ? "rgba(176,0,32,0.25)"
                         : "rgba(154,106,0,0.35)";
  }
}

const TILES = [
  {
    key: "t1_afford",
    title: "1) Median monthly payment (P&I) + 30Y mortgage rate",
    meta: "Bars = estimated monthly P&I payment (left axis). Line = 30Y mortgage rate (right axis).",
    pill: "Windowed",
    build: ({ labelsYM, series, state }) => {
      const price = series.PRICE_ZILLOW;
      const rate = series.MORTGAGE_30Y_M;

      const payments = price.map((p, i) => {
        const r = rate[i];
        if (p === null || r === null) return null;
        const dpDollars = p * (state.dpPct / 100);
        const loan = Math.max(0, p - dpDollars);
        return monthlyPayment(loan, r, 360);
      });

      return {
        labelsYM,
        bar: payments,
        line: rate,
        chartOpts: {
          barLabel: "Est. monthly payment (P&I)",
          lineLabel: "30Y mortgage rate",
          barAxisTitle: "Monthly payment ($)",
          lineAxisTitle: "Mortgage rate (%)",
          barTick: (v) => "$" + fmtMoney0.format(v),
          lineTick: (v) => fmt1.format(v) + "%"
        },
        note: "Home price proxy: Zillow ZHVI. Mortgage rate: Freddie Mac weekly averaged to monthly. Recession shading: USREC."
      };
    },
    kpi: ({ labelsYM, series, state }) => {
      const price = series.PRICE_ZILLOW;
      const rate = series.MORTGAGE_30Y_M;
      const payments = price.map((p, i) => {
        const r = rate[i];
        if (p === null || r === null) return null;
        const dpDollars = p * (state.dpPct / 100);
        const loan = Math.max(0, p - dpDollars);
        return monthlyPayment(loan, r, 360);
      });

      const latest = lastValue(payments);
      const prev12 = payments.length >= 13 ? payments[payments.length-13] : null;
      const yoy = pctChange(latest, prev12);

      return {
        name: "Affordability (P&I)",
        value: latest,
        valueFmt: (v) => v === null ? "—" : "$" + fmtMoney0.format(v),
        yoy,
        yoyFmt: (v) => v === null ? "—" : fmt1.format(v) + "% YoY",
        updatedYM: lastUpdatedYM(labelsYM, payments),
        tag: (value, yoy) => (yoy !== null && yoy < THRESH.AFFORD_YOY_GOOD)
          ? { text:"Improving YoY", cls:"good" }
          : { text:"Watch rates/prices", cls:"warn" }
      };
    }
  },
  {
    key: "t2_ehs",
    title: "2) Existing Home Sales (SAAR) + Months Supply",
    meta: "Bars = existing home sales SAAR (left axis). Line = months supply (right axis).",
    pill: "Windowed (series-dependent history)",
    build: ({ labelsYM, series }) => ({
      labelsYM,
      bar: series.EHS_SAAR,
      line: series.EHS_MONTHS,
      chartOpts: {
        barLabel: "Existing Home Sales (SAAR)",
        lineLabel: "Months supply",
        barAxisTitle: "Sales (SAAR, units)",
        lineAxisTitle: "Months",
        barTick: (v) => fmtNum0.format(v),
        lineTick: (v) => fmt1.format(v)
      },
      note: "Note: some EHS series have short history. Recession shading: USREC."
    }),
    kpi: ({ labelsYM, series }) => {
      const v = lastValue(series.EHS_SAAR);
      const prev12 = series.EHS_SAAR.length >= 13 ? series.EHS_SAAR[series.EHS_SAAR.length-13] : null;
      const yoy = pctChange(v, prev12);
      return {
        name: "Existing Home Sales",
        value: v,
        valueFmt: (x) => x === null ? "—" : fmtNum0.format(x),
        yoy,
        yoyFmt: (x) => x === null ? "—" : fmt1.format(x) + "% YoY",
        updatedYM: lastUpdatedYM(labelsYM, series.EHS_SAAR),
        tag: (_v, yy) => (yy !== null && yy > 0) ? { text:"Rising demand", cls:"good" } : { text:"Weak/flat", cls:"warn" }
      };
    }
  },
  {
    key: "t3_newinv",
    title: "3) New Home Inventory + Months Supply (New Homes)",
    meta: "Bars = new homes for sale (left axis). Line = months supply (right axis).",
    pill: "Windowed",
    build: ({ labelsYM, series }) => ({
      labelsYM,
      bar: series.NEW_INV,
      line: series.NEW_MONTHS,
      chartOpts: {
        barLabel: "New homes for sale (inventory)",
        lineLabel: "Months supply (new homes)",
        barAxisTitle: "Inventory (thousands)",
        lineAxisTitle: "Months",
        barTick: (v) => fmtNum0.format(v),
        lineTick: (v) => fmt1.format(v)
      },
      note: "Inventory: HNFSEPUSSA (thousands). Months supply: MSACSR. Recession shading: USREC."
    }),
    kpi: ({ labelsYM, series }) => {
      const v = lastValue(series.NEW_MONTHS);
      const prev12 = series.NEW_MONTHS.length >= 13 ? series.NEW_MONTHS[series.NEW_MONTHS.length-13] : null;
      const yoy = pctChange(v, prev12);
      return {
        name: "New Home Supply",
        value: v,
        valueFmt: (x) => x === null ? "—" : fmt1.format(x) + " mo",
        yoy,
        yoyFmt: (x) => x === null ? "—" : fmt1.format(x) + "% YoY",
        updatedYM: lastUpdatedYM(labelsYM, series.NEW_MONTHS),
        tag: (x) => (x !== null && x >= 7) ? { text:"High supply", cls:"warn" }
              : (x !== null && x <= 4.5) ? { text:"Tight supply", cls:"good" }
              : { text:"Balanced", cls:"warn" }
      };
    }
  },
  {
    key: "t4_starts",
    title: "4) Single-Family Starts (SAAR) + YoY % (full line)",
    meta: "Bars = single-family starts SAAR (left axis). Line = YoY % change (right axis).",
    pill: "Windowed",
    build: ({ labelsYM, series }) => {
      const starts = series.STARTS_SF;
      const yoy = computeYoYFromAligned(starts, 12);
      return {
        labelsYM,
        bar: starts,
        line: yoy,
        chartOpts: {
          barLabel: "Single-family starts (SAAR)",
          lineLabel: "YoY % change",
          barAxisTitle: "Starts (SAAR)",
          lineAxisTitle: "YoY (%)",
          barTick: (v) => fmtNum0.format(v),
          lineTick: (v) => fmt1.format(v) + "%"
        },
        note: "Starts: HOUST1F (SAAR). YoY computed as t vs t-12. Recession shading: USREC."
      };
    },
    kpi: ({ labelsYM, series }) => {
      const starts = series.STARTS_SF;
      const yoy = computeYoYFromAligned(starts, 12);
      const latestYoY = lastValue(yoy);
      return {
        name: "Single-Family Starts",
        value: lastValue(starts),
        valueFmt: (x) => x === null ? "—" : fmtNum0.format(x),
        yoy: latestYoY,
        yoyFmt: (x) => x === null ? "—" : fmt1.format(x) + "% YoY",
        updatedYM: lastUpdatedYM(labelsYM, starts),
        tag: (_v, yy) => (yy !== null && yy >= THRESH.STARTS_YOY_STRONG) ? { text:"Strong growth", cls:"good" }
             : (yy !== null && yy < 0) ? { text:"Contracting", cls:"warn" }
             : { text:"Mixed", cls:"warn" }
      };
    }
  },
  {
    key: "t5_workers",
    title: "5) Residential construction workers + YoY %",
    meta: "Bars = residential construction employees (left axis). Line = YoY % change (right axis).",
    pill: "Windowed",
    build: ({ labelsYM, series }) => {
      const workers = series.RES_WORKERS;
      const yoy = computeYoYFromAligned(workers, 12);
      return {
        labelsYM,
        bar: workers,
        line: yoy,
        chartOpts: {
          barLabel: "Residential construction employees",
          lineLabel: "YoY % change",
          barAxisTitle: "Employees",
          lineAxisTitle: "YoY (%)",
          barTick: (v) => fmtNum0.format(v),
          lineTick: (v) => fmt1.format(v) + "%"
        },
        note: "Bars: CES2023610001. Line: YoY % change. Recession shading: USREC."
      };
    },
    kpi: ({ labelsYM, series }) => {
      const v = lastValue(series.RES_WORKERS);
      const prev12 = series.RES_WORKERS.length >= 13 ? series.RES_WORKERS[series.RES_WORKERS.length-13] : null;
      const yoy = pctChange(v, prev12);
      return {
        name: "Res. Construction Jobs",
        value: v,
        valueFmt: (x) => x === null ? "—" : fmtNum0.format(x),
        yoy,
        yoyFmt: (x) => x === null ? "—" : fmt1.format(x) + "% YoY",
        updatedYM: lastUpdatedYM(labelsYM, series.RES_WORKERS),
        tag: (_v, yy) => (yy !== null && yy > 0) ? { text:"Hiring", cls:"good" }
             : (yy !== null && yy < 0) ? { text:"Softening", cls:"warn" }
             : { text:"Flat", cls:"warn" }
      };
    }
  },
  {
    key: "t6_macro",
    title: "6) Consumer sentiment + Unemployment rate",
    meta: "Bars = consumer sentiment (left axis). Line = unemployment rate (right axis).",
    pill: "Windowed",
    build: ({ labelsYM, series }) => ({
      labelsYM,
      bar: series.SENTIMENT,
      line: series.UNRATE,
      chartOpts: {
        barLabel: "Consumer sentiment (UMCSENT)",
        lineLabel: "Unemployment rate (UNRATE)",
        barAxisTitle: "Sentiment index",
        lineAxisTitle: "Unemployment (%)",
        barTick: (v) => fmtNum0.format(v),
        lineTick: (v) => fmt1.format(v) + "%"
      },
      note: "Bars: UMCSENT. Line: UNRATE. Recession shading: USREC."
    }),
    kpi: ({ labelsYM, series }) => {
      const un = series.UNRATE;
      const un6m = changeOverN(un, 6);
      const latest6m = lastValue(un6m);
      return {
        name: "Macro (Unemployment)",
        value: lastValue(un),
        valueFmt: (x) => x === null ? "—" : fmt1.format(x) + "%",
        yoy: latest6m,
        yoyFmt: (x) => x === null ? "—" : ((x>=0?"+":"") + fmt1.format(x) + " pp (6m)"),
        updatedYM: lastUpdatedYM(labelsYM, un),
        tag: (_v, d6m) => (d6m !== null && d6m >= THRESH.UNRATE_6M_RISE_WARN)
          ? { text:"Rising jobless", cls:"warn" }
          : { text:"Stable labor", cls:"good" }
      };
    }
  }
];

/* =========================================================
   STATE + CHARTS
========================================================= */
const state = {
  window: elRange.value,
  smooth: Number(elSmooth.value),
  dpPct: Number(elDp.value)
};

let chartsByKey = new Map();
let recessionRanges = [];
let rawMonthly = {};
let labelsYMAll = [];

/* =========================================================
   UI BUILDERS
========================================================= */
function mk(tag, attrs={}, children=[]){
  const el = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v]) => {
    if (k === "class") el.className = v;
    else if (k === "html") el.innerHTML = v;
    else if (k.startsWith("on") && typeof v === "function") el.addEventListener(k.slice(2), v);
    else el.setAttribute(k, v);
  });
  (Array.isArray(children) ? children : [children]).forEach(ch => {
    if (ch === null || ch === undefined) return;
    if (typeof ch === "string") el.appendChild(document.createTextNode(ch));
    else el.appendChild(ch);
  });
  return el;
}

function buildTileShell(tile){
  const card = mk("div", { class:"card", id: `card_${tile.key}` });
  const h2 = mk("h2", {}, tile.title);
  const meta = mk("p", { class:"meta" }, [
    tile.meta + " ",
    mk("span", { class:"pill" }, tile.pill)
  ]);

  const statusRow = mk("div", { class:"tileStatus" }, [
    mk("div", { class:"left" }, [
      mk("span", { class:"pill", id:`upd_${tile.key}` }, "Updated: —"),
      mk("span", { class:"pill", id:`stale_${tile.key}` }, "Staleness: —")
    ]),
    mk("div", { class:"small", id:`lag_${tile.key}` }, "")
  ]);

  const canvas = mk("canvas", { id:`cv_${tile.key}` });
  const note = mk("div", { class:"note", id:`note_${tile.key}` }, "");
  const err = mk("div", { class:"tileErr", id:`err_${tile.key}` }, "");

  card.appendChild(h2);
  card.appendChild(meta);
  card.appendChild(statusRow);
  card.appendChild(canvas);
  card.appendChild(note);
  card.appendChild(err);
  return card;
}

function renderTilesShell(){
  elTiles.innerHTML = "";
  TILES.forEach(t => elTiles.appendChild(buildTileShell(t)));
}

function renderKpis(kpiObjects){
  elKpiGrid.innerHTML = "";
  kpiObjects.forEach(k => {
    const tag = (typeof k.tag === "function") ? k.tag(k.value, k.yoy) : { text:"", cls:"warn" };
    const staleInfo = computeStaleness(k.updatedYM);
    const staleTag = staleInfo.level === "good" ? "good" : (staleInfo.level === "bad" ? "bad" : "warn");

    const card = mk("div", { class:"card kpiCard" }, [
      mk("h3", {}, k.name),
      mk("div", { class:"kpiMain" }, [
        mk("div", { class:"kpiValue" }, k.valueFmt(k.value)),
        mk("div", { class:"kpiDelta" }, k.yoyFmt(k.yoy))
      ]),
      mk("div", { class:"kpiFooter" }, [
        mk("span", { class:`kpiTag ${tag.cls}` }, tag.text || "—"),
        mk("span", { class:`kpiTag ${staleTag}` }, staleInfo.text)
      ])
    ]);
    elKpiGrid.appendChild(card);
  });
}

/* =========================================================
   COMMENTARY (external + auto signals)
========================================================= */
async function fetchInsights({ bypassCache=false } = {}) {
  if (!elInsightsStatus || !elInsightsErr) return;

  try {
    elInsightsStatus.textContent = "Fetching latest commentary...";
    elInsightsErr.textContent = "";
    elBuildersWrap.innerHTML = "";
    elMarketBullets.innerHTML = "";

    const url = new URL(INSIGHTS_URL);
    if (bypassCache) url.searchParams.set("nocache", "1");

    const resp = await fetch(url.toString());
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error("Insights failed (" + resp.status + "): " + txt);
    }
    const data = await resp.json();
    elInsightsStatus.textContent = "As of " + (data.as_of || "latest") + ":";

    const builders = data.builders || {};
    const order = [
      ["DHI", "D.R. Horton (DHI)"],
      ["LEN", "Lennar (LEN)"],
      ["PHM", "PulteGroup (PHM)"]
    ];
    for (const [key, label] of order) {
      const bullets = Array.isArray(builders[key]) ? builders[key] : [];
      const section = mk("div", { style:"margin:6px 0 10px;" }, [
        mk("div", { style:"font-weight:700; margin-bottom:4px;" }, label),
        mk("ul", { style:"margin:0 0 0 18px;" }, bullets.map(b => mk("li", {}, b)))
      ]);
      elBuildersWrap.appendChild(section);
    }

    const marketBullets = (data.market && Array.isArray(data.market.bullets)) ? data.market.bullets : [];
    marketBullets.forEach(b => elMarketBullets.appendChild(mk("li", {}, b)));

  } catch (e) {
    elInsightsStatus.textContent = "Could not load external commentary.";
    elInsightsErr.textContent = String(e && e.message ? e.message : e);
    console.error(e);
  }
}

function renderAutoSignals(kpis){
  if (!elSignalsBullets) return;
  elSignalsBullets.innerHTML = "";
  const byName = new Map(kpis.map(k => [k.name, k]));

  const aff = byName.get("Affordability (P&I)");
  const starts = byName.get("Single-Family Starts");
  const ehs = byName.get("Existing Home Sales");
  const un = byName.get("Macro (Unemployment)");
  const supply = byName.get("New Home Supply");

  const bullets = [];

  if (aff && aff.yoy !== null){
    bullets.push(
      aff.yoy < 0
        ? `Affordability improving: estimated P&I payment is ${fmt1.format(aff.yoy)}% YoY (down).`
        : `Affordability still tightening: estimated P&I payment is ${fmt1.format(aff.yoy)}% YoY (up).`
    );
  }
  if (starts && starts.yoy !== null){
    bullets.push(
      starts.yoy >= THRESH.STARTS_YOY_STRONG
        ? `Construction momentum: single-family starts are running ${fmt1.format(starts.yoy)}% YoY.`
        : `Starts signal is mixed: single-family starts are ${fmt1.format(starts.yoy)}% YoY.`
    );
  }
  if (ehs && ehs.yoy !== null){
    bullets.push(
      ehs.yoy > 0
        ? `Resale demand improving: existing home sales are ${fmt1.format(ehs.yoy)}% YoY.`
        : `Resale demand soft/flat: existing home sales are ${fmt1.format(ehs.yoy)}% YoY.`
    );
  }
  if (un && un.yoy !== null){
    bullets.push(
      un.yoy >= THRESH.UNRATE_6M_RISE_WARN
        ? `Macro watch: unemployment is up ${fmt1.format(un.yoy)} pp over 6 months.`
        : `Labor market stable: unemployment change over 6 months is ${un.yoy>=0?"+":""}${fmt1.format(un.yoy)} pp.`
    );
  }
  if (supply && supply.value !== null){
    bullets.push(
      supply.value >= 7
        ? `New home supply is elevated (${fmt1.format(supply.value)} months), typically more promotional pressure.`
        : `New home supply is moderate/tight (${fmt1.format(supply.value)} months), typically supportive of pricing.`
    );
  }

  if (!bullets.length) bullets.push("Signals unavailable (insufficient data history for selected window).");
  bullets.forEach(b => elSignalsBullets.appendChild(mk("li", {}, b)));
}

/* =========================================================
   DATA LOAD + RENDER PIPELINE
========================================================= */
async function loadAllSeries({ bypassCache=false } = {}) {
  const [
    priceRaw,
    mortWeeklyRaw,
    ehsRaw,
    ehsMonthsRaw,
    newInvRaw,
    newMonthsRaw,
    startsRaw,
    resWorkersRaw,
    sentimentRaw,
    unrateRaw,
    usrecRaw
  ] = await Promise.all([
    fetchSeries(SERIES.PRICE_ZILLOW, { bypassCache }),
    fetchSeries(SERIES.MORTGAGE_30Y, { bypassCache }),
    fetchSeries(SERIES.EHS_SAAR, { bypassCache }),
    fetchSeries(SERIES.EHS_MONTHS, { bypassCache }),
    fetchSeries(SERIES.NEW_INV, { bypassCache }),
    fetchSeries(SERIES.NEW_MONTHS, { bypassCache }),
    fetchSeries(SERIES.STARTS_SF, { bypassCache }),
    fetchSeries(SERIES.RES_WORKERS, { bypassCache }),
    fetchSeries(SERIES.SENTIMENT, { bypassCache }),
    fetchSeries(SERIES.UNRATE, { bypassCache }),
    fetchSeries(SERIES.USREC, { bypassCache })
  ]);

  return {
    PRICE_ZILLOW: priceRaw,
    MORTGAGE_30Y_M: toMonthlyAverage(mortWeeklyRaw),
    EHS_SAAR: ehsRaw,
    EHS_MONTHS: ehsMonthsRaw,
    NEW_INV: newInvRaw,
    NEW_MONTHS: newMonthsRaw,
    STARTS_SF: startsRaw,
    RES_WORKERS: resWorkersRaw,
    SENTIMENT: sentimentRaw,
    UNRATE: unrateRaw,
    USREC: usrecRaw
  };
}

function buildMonthlyAligned(seriesObsByName, window){
  const sliced = {};
  Object.entries(seriesObsByName).forEach(([name, obs]) => {
    sliced[name] = sliceWindow(obs, window);
  });

  const seriesList = Object.entries(sliced).map(([name, obs]) => ({ name, obs }));
  const aligned = alignMonthlyUnion(seriesList);

  const labelsYM = aligned.keys;
  const values = aligned.valuesBySeries;

  const out = { labelsYM };
  seriesList.forEach((s, idx) => { out[s.name] = values[idx]; });
  return out;
}

function applySmoothing(seriesAligned, smoothWindow){
  if (!smoothWindow || smoothWindow <= 1) return seriesAligned;
  const out = { labelsYM: seriesAligned.labelsYM.slice() };
  Object.entries(seriesAligned).forEach(([k, v]) => {
    if (k === "labelsYM") return;
    out[k] = rollingMA(v, smoothWindow);
  });
  return out;
}

function renderAll(){
  const labelsYM = labelsYMAll;
  const series = rawMonthly;

  if (!Chart.registry.plugins.get("recessionShading")) Chart.register(makeRecessionPlugin(() => recessionRanges));
  if (!Chart.registry.plugins.get("latestLabel")) Chart.register(makeLatestLabelPlugin());

  const kpis = TILES.map(t => t.kpi({ labelsYM, series, state })).filter(Boolean);
  renderKpis(kpis);
  renderAutoSignals(kpis);

  TILES.forEach(tile => {
    const cv = document.getElementById(`cv_${tile.key}`);
    const noteEl = document.getElementById(`note_${tile.key}`);
    const errEl = document.getElementById(`err_${tile.key}`);
    const lagEl = document.getElementById(`lag_${tile.key}`);

    if (!cv || !noteEl || !errEl) return;

    errEl.textContent = "";
    noteEl.textContent = "";
    if (lagEl) lagEl.textContent = "";

    try {
      const built = tile.build({ labelsYM, series, state });

      const updatedYM = lastUpdatedYM(built.labelsYM, built.bar) || lastUpdatedYM(built.labelsYM, built.line);
      const staleness = computeStaleness(updatedYM);
      setTileUpdateBadges(tile.key, updatedYM, staleness);

      const existing = chartsByKey.get(tile.key);
      if (existing) { existing.destroy(); chartsByKey.delete(tile.key); }

      let barData = built.bar.slice();
      let lineData = built.line.slice();
      if (state.smooth && state.smooth > 1) {
        barData = rollingMA(barData, state.smooth);
        lineData = rollingMA(lineData, state.smooth);
      }

      const chart = makeMixedBarLineChart(cv, built.labelsYM, barData, lineData, built.chartOpts);
      chartsByKey.set(tile.key, chart);

      noteEl.textContent = built.note || "";

      if (lagEl) {
        const nonNullCount = barData.filter(v => v !== null && v !== undefined).length;
        if (nonNullCount < 36) lagEl.textContent = "Short history: plotting all available observations.";
      }

    } catch (e) {
      errEl.textContent = String(e && e.message ? e.message : e);
      console.error(tile.key, e);
    }
  });
}

/* =========================================================
   MAIN LOAD
========================================================= */
async function reloadAll({ bypassCache=false } = {}) {
  elErrText.textContent = "";
  elStatusText.textContent = "Fetching series…";
  elReload.disabled = true;

  try {
    const obs = await loadAllSeries({ bypassCache });

    const usrecWindowed = sliceWindow(obs.USREC, state.window);
    recessionRanges = recessionRangesFromUSREC(usrecWindowed);

    const monthlyAligned = buildMonthlyAligned(obs, state.window);
    const smoothed = applySmoothing(monthlyAligned, state.smooth);

    labelsYMAll = smoothed.labelsYM;
    rawMonthly = smoothed;

    fetchInsights({ bypassCache });
    renderAll();

    const latestYM = labelsYMAll.length ? labelsYMAll[labelsYMAll.length-1] : null;
    elStatusText.innerHTML =
      `<span class="ok">Loaded</span> ${Object.keys(obs).length} series. Window: <b>${state.window}</b>. Latest month on x-axis: <b>${latestYM ? formatYM(latestYM) : "—"}</b>.`;

  } catch (e) {
    elStatusText.textContent = "Could not load data.";
    elErrText.textContent = String(e && e.message ? e.message : e);
    console.error(e);
  } finally {
    elReload.disabled = false;
  }
}

/* =========================================================
   EVENTS
========================================================= */
elRange.addEventListener("change", () => {
  state.window = elRange.value;
  reloadAll({ bypassCache: false });
});

elSmooth.addEventListener("change", () => {
  state.smooth = Number(elSmooth.value || 0);
  if (!Number.isFinite(state.smooth)) state.smooth = 0;
  reloadAll({ bypassCache: false });
});

elDp.addEventListener("input", () => {
  state.dpPct = Number(elDp.value || 0);
  if (!Number.isFinite(state.dpPct)) state.dpPct = 20;
  state.dpPct = Math.max(0, Math.min(50, state.dpPct));
  elDpLabel.textContent = state.dpPct + "%";
  renderAll();
});

elRefresh.addEventListener("click", () => {
  clearAllLocalCache();
  elStatusText.innerHTML = `<span class="warn">Local cache cleared.</span> Click “Reload data” to refetch from proxy.`;
});

elReload.addEventListener("click", () => {
  reloadAll({ bypassCache: true });
});

/* =========================================================
   BOOT
========================================================= */
renderTilesShell();
elDpLabel.textContent = elDp.value + "%";
reloadAll({ bypassCache: false });
</script>

</body>
</html>
