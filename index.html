<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Housing Data Central</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --border:#e6e6e6;
      --muted:#666;
      --bg:#ffffff;
      --card:#ffffff;
      --shadow: 0 1px 10px rgba(0,0,0,0.04);
    }
    body { font-family: Arial, sans-serif; margin: 22px; line-height: 1.35; background: var(--bg); color:#111; }
    h1 { margin: 0 0 6px; font-size: 22px; }
    .sub { color: var(--muted); margin: 0 0 16px; }
    .status { border: 1px solid var(--border); border-radius: 12px; padding: 14px 14px; margin: 14px 0 18px; background: var(--card); box-shadow: var(--shadow); }
    .ok { color: #1a7f37; }
    .error { color: #b00020; white-space: pre-wrap; margin-top: 8px; }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    @media (min-width: 1100px) {
      .grid { grid-template-columns: 1fr 1fr; }
    }

    .card { border: 1px solid var(--border); border-radius: 12px; padding: 14px; background: var(--card); box-shadow: var(--shadow); }
    .card h2 { margin: 0 0 6px; font-size: 16px; }
    .meta { color: var(--muted); font-size: 12.5px; margin: 0 0 10px; }
    .note { color: var(--muted); font-size: 12.5px; margin-top: 8px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    label { font-size: 12.5px; color: var(--muted); }
    input[type="number"]{ padding: 7px 9px; border:1px solid var(--border); border-radius:10px; width: 160px; }
    canvas { width: 100% !important; height: 280px !important; }
    .small { font-size: 12.5px; color: var(--muted); }
    .pill { display:inline-block; padding:3px 8px; border:1px solid var(--border); border-radius: 999px; font-size: 12px; color:#333; background:#fafafa; }
  </style>
</head>

<body>
  <h1>Housing Dashboard</h1>
  <p class="sub">Four-tile landing page pulling public series from FRED via your Cloudflare proxy.</p>

  <div class="status">
    <div id="statusText">Loading…</div>
    <div id="errText" class="error"></div>
  </div>

  <div class="card">
  <h2 style="margin-top:0;">Builder commentary (auto)</h2>
  <div id="insightsStatus">Loading commentary...</div>
  <ul id="insightsBullets" style="margin: 10px 0 0 18px;"></ul>
  <div class="note" id="insightsMeta"></div>
  <div id="insightsErr" class="error"></div>
</div>

  <div class="grid">
    <!-- TILE 1 -->
    <div class="card">
      <h2>1) Median monthly payment (P&I) + 30Y mortgage rate</h2>
      <p class="meta">
        Bars = estimated monthly P&I payment (left axis). Line = 30Y mortgage rate (right axis).
        <span class="pill">20Y window</span>
      </p>

      <div class="row" style="margin-bottom:10px;">
        <label for="downPaymentPct">Down payment</label>
<input id="downPaymentPct" type="range" min="0" max="50" step="1" value="20" style="width:220px;" />
<span id="dpPctLabel" class="pill">20%</span>
<span id="dpHint" class="small" style="margin-left:6px;"></span>

      </div>

      <canvas id="chart1"></canvas>
      <div id="tile1note" class="note"></div>
    </div>

    <!-- TILE 2 -->
    <div class="card">
      <h2>2) Existing Home Sales (SAAR) + Months Supply</h2>
      <p class="meta">
        Bars = existing home sales SAAR (left axis). Line = months supply (right axis).
        <span class="pill">20Y window (shows what exists)</span>
      </p>
      <canvas id="chart2"></canvas>
      <div id="tile2note" class="note"></div>
    </div>

    <!-- TILE 3 -->
    <div class="card">
      <h2>3) New Home Inventory + Months Supply (New Homes)</h2>
      <p class="meta">
        Bars = new homes for sale (left axis). Line = months supply (right axis).
        <span class="pill">20Y window</span>
      </p>
      <canvas id="chart3"></canvas>
      <div id="tile3note" class="note"></div>
    </div>

    <!-- TILE 4 -->
    <div class="card">
      <h2>4) Single-Family Permits (SAAR) + YoY % (full line)</h2>
      <p class="meta">
        Bars = permits SAAR (left axis). Line = YoY % change (right axis, every month).
        <span class="pill">20Y window</span>
      </p>
      <canvas id="chart4"></canvas>
      <div id="tile4note" class="note"></div>
    </div>
  </div>

<script>
/* =========================
   CONFIG
========================= */
const PROXY_BASE = "https://fred-proxy.patrick-grow.workers.dev";

 const INSIGHTS_URL = PROXY_BASE.replace(/\/$/, "") + "/insights";

async function fetchInsights() {
  const status = document.getElementById("insightsStatus");
  const bulletsEl = document.getElementById("insightsBullets");
  const metaEl = document.getElementById("insightsMeta");
  const errEl = document.getElementById("insightsErr");

  // If the card isn’t on the page for some reason, just skip
  if (!status || !bulletsEl || !metaEl || !errEl) return;

  try {
    status.textContent = "Fetching latest builder commentary...";
    bulletsEl.innerHTML = "";
    metaEl.textContent = "";
    errEl.textContent = "";

    const resp = await fetch(INSIGHTS_URL);
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error("Insights failed (" + resp.status + "): " + txt);
    }

    const data = await resp.json();
    status.textContent = "As of " + (data.as_of || "latest") + ":";

    (data.bullets || []).forEach(b => {
      const li = document.createElement("li");
      li.textContent = b;
      bulletsEl.appendChild(li);
    });

    metaEl.textContent = ""; // sources removed


  } catch (e) {
    status.textContent = "Could not load commentary.";
    errEl.textContent = String(e && e.message ? e.message : e);
    console.error(e);
  }
} 

  
// Tile 1 inputs
const SERIES_PRICE_PROXY = "USAUCSFRCONDOSMSAMID";  // Zillow ZHVI (US) (monthly, dollars) :contentReference[oaicite:10]{index=10}
const SERIES_MORTGAGE_30Y = "MORTGAGE30US";         // Freddie Mac weekly rate :contentReference[oaicite:11]{index=11}

// Tile 2
const SERIES_EHS = "EXHOSLUSM495S";                 // Existing Home Sales SAAR (short history) :contentReference[oaicite:12]{index=12}
const SERIES_EHS_MONTHS = "HOSSUPUSM673N";          // Existing Home Sales: Months Supply :contentReference[oaicite:13]{index=13}

// Tile 3
const SERIES_NEW_INV = "HNFSEPUSSA";                // New One Family Homes for Sale :contentReference[oaicite:14]{index=14}
const SERIES_NEW_MONTHS = "MSACSR";                 // Months supply new houses :contentReference[oaicite:15]{index=15}

// Tile 4
const SERIES_PERMITS_SF = "PERMIT1";                // Single-family permits SAAR :contentReference[oaicite:16]{index=16}

// Recession shading
const SERIES_USREC = "USREC";                       // NBER recession indicator :contentReference[oaicite:17]{index=17}

const YEARS = 20;
const CACHE_TTL_MS = 12 * 60 * 60 * 1000; // 12 hours
const CACHE_PREFIX = "fredcache_v1:";


/* =========================
   HELPERS
========================= */
const fmtMonth = new Intl.DateTimeFormat("en-US", { year: "numeric", month: "short" });
const fmtMoney0 = new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 });
const fmtNum0 = new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 });
const fmtPct1 = new Intl.NumberFormat("en-US", { maximumFractionDigits: 1, minimumFractionDigits: 1 });

function parseFredValue(v) {
  if (v === "." || v === null || v === undefined) return null;
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

function ymdToDate(s) { return new Date(s + "T00:00:00"); }

function monthKey(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  return `${y}-${m}`;
}

function addYears(dateObj, years) {
  const d = new Date(dateObj);
  d.setFullYear(d.getFullYear() + years);
  return d;
}

function pctChange(curr, prev) {
  if (curr === null || prev === null || prev === 0) return null;
  return (curr / prev - 1) * 100;
}

function mean(arr) {
  const clean = arr.filter(x => x !== null && x !== undefined);
  if (!clean.length) return null;
  return clean.reduce((a,b)=>a+b,0) / clean.length;
}

// Loan payment formula (P&I): M = L * r / (1 - (1+r)^-n)
function monthlyPayment(loanAmount, annualRatePct, nMonths=360) {
  if (loanAmount === null || annualRatePct === null) return null;
  const r = (annualRatePct / 100) / 12;
  if (r === 0) return loanAmount / nMonths;
  const denom = 1 - Math.pow(1 + r, -nMonths);
  if (denom === 0) return null;
  return loanAmount * r / denom;
}

/* =========================
   FETCH (via your proxy)
========================= */
function cacheKeyForSeries(seriesId) {
  return CACHE_PREFIX + seriesId;
}

function readCache(seriesId) {
  try {
    const raw = localStorage.getItem(cacheKeyForSeries(seriesId));
    if (!raw) return null;

    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return null;

    const { savedAt, data } = parsed;
    if (!savedAt || !data) return null;

    // TTL check
    if ((Date.now() - savedAt) > CACHE_TTL_MS) return null;

    return data;
  } catch {
    return null;
  }
}

function writeCache(seriesId, data) {
  try {
    const payload = { savedAt: Date.now(), data };
    localStorage.setItem(cacheKeyForSeries(seriesId), JSON.stringify(payload));
  } catch {
    // If localStorage is full or blocked, silently continue without caching
  }
}

async function fetchSeries(seriesId) {
  // 1) Try cache first
  const cached = readCache(seriesId);
  if (cached && Array.isArray(cached.observations)) {
    const obsCached = cached.observations
      .map(o => ({ date: ymdToDate(o.date), value: parseFredValue(o.value) }))
      .filter(o => o.value !== null)
      .sort((a, b) => a.date - b.date);

    if (obsCached.length) return obsCached;
    // fall through to live fetch if cache is malformed
  }

  // 2) Live fetch
  const url = new URL(PROXY_BASE);
  url.searchParams.set("series_id", seriesId);
  url.searchParams.set("file_type", "json");

  const resp = await fetch(url.toString());
  if (!resp.ok) {
    const txt = await resp.text();
    throw new Error(`${seriesId} failed (${resp.status}). Response:\n${txt}`);
  }

  const data = await resp.json();

  // 3) Save to cache (raw JSON) for next load
  writeCache(seriesId, data);

  if (!data || !Array.isArray(data.observations)) throw new Error(`${seriesId} unexpected response shape.`);

  const obs = data.observations
    .map(o => ({ date: ymdToDate(o.date), value: parseFredValue(o.value) }))
    .filter(o => o.value !== null)
    .sort((a, b) => a.date - b.date);

  if (!obs.length) throw new Error(`${seriesId}: no observations after filtering.`);
  return obs;
}


/* Convert any frequency to monthly averages (e.g., weekly mortgage rate -> monthly) */
function toMonthlyAverage(obs) {
  const bucket = new Map(); // key -> {sum, count}
  for (const o of obs) {
    const k = monthKey(o.date);
    const cur = bucket.get(k) || { sum: 0, count: 0, date: new Date(o.date.getFullYear(), o.date.getMonth(), 1) };
    cur.sum += o.value;
    cur.count += 1;
    bucket.set(k, cur);
  }
  const out = Array.from(bucket.entries())
    .map(([k,v]) => ({ date: v.date, value: v.sum / v.count }))
    .sort((a,b)=>a.date-b.date);
  return out;
}

/* Filter to last N years using the series' own latest date */
function lastNYears(obs, years) {
  const latest = obs[obs.length - 1].date;
  const start = addYears(latest, -years);
  return obs.filter(o => o.date >= start);
}

/* Align two monthly series by month (intersection) */
function alignMonthly(aObs, bObs) {
  const aMap = new Map(aObs.map(o => [monthKey(o.date), o.value]));
  const bMap = new Map(bObs.map(o => [monthKey(o.date), o.value]));
  const keys = Array.from(aMap.keys()).filter(k => bMap.has(k)).sort();
  const dates = keys.map(k => {
    const [y,m] = k.split("-");
    return new Date(Number(y), Number(m)-1, 1);
  });
  const aVals = keys.map(k => aMap.get(k));
  const bVals = keys.map(k => bMap.get(k));
  return { dates, aVals, bVals, keys };
}

/* =========================
   RECESSION SHADING
========================= */
function recessionRangesFromUSREC(usrecMonthlyObs) {
  // Expect monthly obs: 1 during recession, 0 otherwise
  const sorted = [...usrecMonthlyObs].sort((a,b)=>a.date-b.date);
  const ranges = [];
  let inRec = false;
  let start = null;

  for (const o of sorted) {
    const isRec = o.value >= 1;
    if (!inRec && isRec) { inRec = true; start = o.date; }
    if (inRec && !isRec) {
      // end at previous month
      const end = new Date(o.date.getFullYear(), o.date.getMonth(), 1);
      ranges.push({ start, end });
      inRec = false; start = null;
    }
  }
  if (inRec && start) {
    const last = sorted[sorted.length - 1].date;
    const end = new Date(last.getFullYear(), last.getMonth()+1, 1);
    ranges.push({ start, end });
  }
  return ranges;
}

function makeRecessionPlugin(getRanges) {
  return {
    id: "recessionShading",
    beforeDatasetsDraw(chart) {
      const ranges = getRanges();
      if (!ranges || !ranges.length) return;

      const { ctx, chartArea, scales } = chart;
      const x = scales.x;
      if (!x || !chartArea) return;

      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.06)";

      // Works reliably for category scale if we map by label index
      const labels = chart.data.labels || [];
      const labelToIndex = new Map(labels.map((lab,i)=>[lab,i]));

      function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

      for (const r of ranges) {
        // Convert start/end to month labels
        const startLab = fmtMonth.format(new Date(r.start.getFullYear(), r.start.getMonth(), 1));
        const endLab = fmtMonth.format(new Date(r.end.getFullYear(), r.end.getMonth()-1, 1)); // last included month

        if (!labelToIndex.has(startLab) || !labelToIndex.has(endLab)) continue;

        const i0 = labelToIndex.get(startLab);
        const i1 = labelToIndex.get(endLab);

        const px0 = x.getPixelForValue(i0);
        const px1 = x.getPixelForValue(i1);

        const left = clamp(Math.min(px0, px1), chartArea.left, chartArea.right);
        const right = clamp(Math.max(px0, px1), chartArea.left, chartArea.right);

        ctx.fillRect(left, chartArea.top, right - left, chartArea.bottom - chartArea.top);
      }

      ctx.restore();
    }
  };
}

/* =========================
   CHART BUILDERS
========================= */
function makeMixedBarLineChart(canvasId, labels, barData, lineData, opts) {
  const ctx = document.getElementById(canvasId);

  return new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          type: "bar",
          label: opts.barLabel,
          data: barData,
          yAxisID: "yBar",
          backgroundColor: "rgba(60, 120, 200, 0.45)",
          borderColor: "rgba(60, 120, 200, 0.85)",
          borderWidth: 1
        },
        {
          type: "line",
          label: opts.lineLabel,
          data: lineData,
          yAxisID: "yLine",
          tension: 0.15,
          pointRadius: 0,
          borderWidth: 2,
          borderColor: "rgba(220, 90, 80, 0.95)"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true }
      },
      scales: {
        x: { ticks: { maxTicksLimit: 12 } },
        yBar: {
          position: "left",
          ticks: { callback: (v) => opts.barTick(v) },
          title: { display: true, text: opts.barAxisTitle }
        },
        yLine: {
          position: "right",
          grid: { drawOnChartArea: false },
          ticks: { callback: (v) => opts.lineTick(v) },
          title: { display: true, text: opts.lineAxisTitle }
        }
      }
    }
  });
}

/* =========================
   MAIN
========================= */
let charts = {};
let recessionRanges = [];

(async function main() {
  fetchInsights();
  
  const statusText = document.getElementById("statusText");
  const errText = document.getElementById("errText");

  try {
    statusText.textContent = "Fetching series…";
    errText.textContent = "";

    // Pull everything up front (Option A)
    const [
      priceRaw,
      mortWeeklyRaw,
      ehsRaw,
      ehsMonthsRaw,
      newInvRaw,
      newMonthsRaw,
      permitsRaw,
      usrecRaw
    ] = await Promise.all([
      fetchSeries(SERIES_PRICE_PROXY),
      fetchSeries(SERIES_MORTGAGE_30Y),
      fetchSeries(SERIES_EHS),
      fetchSeries(SERIES_EHS_MONTHS),
      fetchSeries(SERIES_NEW_INV),
      fetchSeries(SERIES_NEW_MONTHS),
      fetchSeries(SERIES_PERMITS_SF),
      fetchSeries(SERIES_USREC)
    ]);

    // Monthly conversions + 20Y slicing
    const price = lastNYears(priceRaw, YEARS);
    const mortMonthly = lastNYears(toMonthlyAverage(mortWeeklyRaw), YEARS);
    const ehs = lastNYears(ehsRaw, YEARS);
    const ehsMonths = lastNYears(ehsMonthsRaw, YEARS);
    const newInv = lastNYears(newInvRaw, YEARS);
    const newMonths = lastNYears(newMonthsRaw, YEARS);
    const permits = lastNYears(permitsRaw, YEARS);
    const usrecMonthly = lastNYears(usrecRaw, YEARS);

    recessionRanges = recessionRangesFromUSREC(usrecMonthly);

    // Add shading plugin globally
    Chart.register(makeRecessionPlugin(() => recessionRanges));

    // -------------------------
    // TILE 1: payment + rate
    // -------------------------
    const aligned1 = alignMonthly(price, mortMonthly);
    const labels1 = aligned1.dates.map(d => fmtMonth.format(d));

   const latestPrice = aligned1.aVals[aligned1.aVals.length - 1];

const dpPctInput = document.getElementById("downPaymentPct");
const dpPctLabel = document.getElementById("dpPctLabel");

// Default slider value
dpPctInput.value = "20";
dpPctLabel.textContent = "20%";


   function computePayments(dpPct) {
  return aligned1.aVals.map((p, i) => {
    const rate = aligned1.bVals[i];
    const dpDollars = p * (dpPct / 100);
    const loan = Math.max(0, p - dpDollars);
    return monthlyPayment(loan, rate, 360);
  });
}


    const payments0 = computePayments(20);


    charts.c1 = makeMixedBarLineChart("chart1", labels1, payments0, aligned1.bVals, {
      barLabel: "Est. monthly payment (P&I)",
      lineLabel: "30Y mortgage rate",
      barAxisTitle: "Monthly payment ($)",
      lineAxisTitle: "Mortgage rate (%)",
      barTick: (v) => "$" + fmtMoney0.format(v),
      lineTick: (v) => fmtPct1.format(v) + "%"
    });

    // Notes / labels
    const tile1note = document.getElementById("tile1note");
    tile1note.textContent =
      "Home price proxy: Zillow ZHVI (typical home value; monthly, dollars). Mortgage rate is Freddie Mac weekly series averaged to monthly. Recession shading is USREC.";

   const dpHint = document.getElementById("dpHint");
function updateDpHint(dpPct) {
  if (!latestPrice) { dpHint.textContent = ""; return; }
  const dpDollarsLatest = latestPrice * (dpPct / 100);
  const ltv = 100 - dpPct;

  dpHint.textContent =
    `Latest price: $${fmtMoney0.format(latestPrice)} • Down: ${dpPct}% ($${fmtMoney0.format(dpDollarsLatest)}) • LTV: ${fmtPct1.format(ltv)}%`;
}
updateDpHint(20);


    dpPctInput.addEventListener("input", () => {
  let dpPct = Number(dpPctInput.value || 0);
  if (!Number.isFinite(dpPct)) dpPct = 0;

  // Clamp to slider range (0–50)
  dpPct = Math.max(0, Math.min(50, dpPct));

  dpPctLabel.textContent = dpPct + "%";

  const payments = computePayments(dpPct);
  charts.c1.data.datasets[0].data = payments;
  charts.c1.update();
  updateDpHint(dpPct);
});


    // -------------------------
    // TILE 2: existing sales + months supply
    // -------------------------
    const aligned2 = alignMonthly(ehs, ehsMonths);
    const labels2 = aligned2.dates.map(d => fmtMonth.format(d));

    charts.c2 = makeMixedBarLineChart("chart2", labels2, aligned2.aVals, aligned2.bVals, {
      barLabel: "Existing Home Sales (SAAR)",
      lineLabel: "Months supply",
      barAxisTitle: "Sales (SAAR, units)",
      lineAxisTitle: "Months",
      barTick: (v) => fmtNum0.format(v),
      lineTick: (v) => fmtPct1.format(v)
    });

    const tile2note = document.getElementById("tile2note");
    tile2note.textContent =
      (labels2.length < 36)
        ? "Note: FRED’s Existing Home Sales + Months Supply series currently only provide recent history (begins Dec 2024). This tile plots all available data."
        : "Recession shading is USREC.";

    // -------------------------
    // TILE 3: new inventory + months supply
    // -------------------------
    const aligned3 = alignMonthly(newInv, newMonths);
    const labels3 = aligned3.dates.map(d => fmtMonth.format(d));

    charts.c3 = makeMixedBarLineChart("chart3", labels3, aligned3.aVals, aligned3.bVals, {
      barLabel: "New homes for sale (inventory)",
      lineLabel: "Months supply (new homes)",
      barAxisTitle: "Inventory (thousands)",
      lineAxisTitle: "Months",
      barTick: (v) => fmtNum0.format(v),
      lineTick: (v) => fmtPct1.format(v)
    });

    document.getElementById("tile3note").textContent =
      "Inventory series is 'New One Family Homes for Sale' (thousands). Months supply is MSACSR. Recession shading is USREC.";

    // -------------------------
    // TILE 4: permits + YoY line
    // -------------------------
    const permits20 = permits; // already 20Y
    const labels4 = permits20.map(o => fmtMonth.format(o.date));
    const permitVals = permits20.map(o => o.value);
    const yoyVals = permits20.map((o, i) => (i >= 12) ? pctChange(o.value, permits20[i-12].value) : null);

    charts.c4 = makeMixedBarLineChart("chart4", labels4, permitVals, yoyVals, {
      barLabel: "Single-family permits (SAAR)",
      lineLabel: "YoY % change",
      barAxisTitle: "Permits (SAAR)",
      lineAxisTitle: "YoY (%)",
      barTick: (v) => fmtNum0.format(v),
      lineTick: (v) => fmtPct1.format(v) + "%"
    });

    document.getElementById("tile4note").textContent =
      "YoY line is computed for every month (t vs t-12). Recession shading is USREC.";

    // Status
    const latestAny = priceRaw[priceRaw.length - 1].date;
    statusText.innerHTML = `<span class="ok">Loaded</span> all series. Latest price-proxy observation: ${fmtMonth.format(latestAny)}.`;

  } catch (e) {
    statusText.textContent = "Could not load data.";
    errText.textContent = String(e && e.message ? e.message : e);
    console.error(e);
  }
})();
</script>

</body>
</html>
